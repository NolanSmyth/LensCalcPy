# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/07_lens.ipynb.

# %% auto 0
__all__ = ['Lens']

# %% ../nbs/07_lens.ipynb 3
from .parameters import *
from .utils import *

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import nquad, dblquad
import pickle
from abc import ABC, abstractmethod

# %% ../nbs/07_lens.ipynb 5
class Lens(ABC):
    """Abstract class for lens objects.
    """
    def __init__(self, mass):
        self.ut_interp = ut_interp
        self.mass = mass
        pass

    def __str__(self):
        pass

    __repr__ = __str__

    def umin_lower_bound(self, d):
        return 0

    def umin_upper_bound(self, d):
        pass

    def differential_rate_integrand(self, umin, d, t, dist_func, density_func, v_disp_func, finite=False, density_func_uses_d=False):
        r = dist_func(d)
        ut = self.umin_upper_bound(d) if (self.ut_interp and finite) else 1
        if ut <= umin:
            return 0
        v_rad = velocity_radial(d, self.mass, umin, t * htosec, ut)
        v_disp = v_disp_func(r)
        density_input = d if density_func_uses_d else r
        return 2 * (1 / (ut**2 - umin**2)**0.5 *
                density_func(density_input) / (self.mass * v_disp**2) *
                v_rad**4 * (htosec / kpctokm)**2 *
                np.exp(-(v_rad**2 / v_disp**2)))
    
    def differential_rate(self, t, integrand_func, finite=False):
        if finite:
            result, error = dblquad(integrand_func, 0, ds, self.umin_lower_bound, self.umin_upper_bound, args=[t])
            return result    
        else:
            umin_bounds = [0, ut]
            d_bounds = [0, ds]
            result, error = nquad(integrand_func, [umin_bounds, d_bounds], args=[t])
            return result

    @abstractmethod
    def compute_differential_rate(self, t, finite=False):
        # return self.differential_rate(t, finite)
        pass


# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/08_galaxy.ipynb.

# %% auto 0
__all__ = ['Galaxy', 'MilkyWayModel', 'M31Model']

# %% ../nbs/08_galaxy.ipynb 3
from .parameters import *
from .utils import *
from .lens import *

import numpy as np
import matplotlib.pyplot as plt

from fastcore.test import *

from abc import ABC, abstractmethod

# %% ../nbs/08_galaxy.ipynb 5
class Galaxy(ABC):
    def __init__(self, parameters):
        # Initialize common parameters
        for key, value in parameters.items():
            setattr(self, key, value)

    @abstractmethod
    def velocity_dispersion_stars(self, r, v_c):
        # Velocity dispersion of stars at distance r from center of galaxy
        pass
    
    @abstractmethod
    def dist_center(self, d):
        #Distance from center of galaxy for given distance d along line of sight given by l, b
        pass
    
    @abstractmethod
    def density_stars(self, r):
        # Density of stars at distance r from center of galaxy
        pass

    @abstractmethod
    def density_dm(self, r):
        # Density of dark matter at distance r from center of galaxy
        pass

# %% ../nbs/08_galaxy.ipynb 6
class MilkyWayModel(Galaxy):
    def __init__(self, parameters):
        super().__init__(parameters)

    def dist_center(self, d: float, # distance from the Sun in kpc
            ) -> float: #distance to the MW center in kpc
        return np.sqrt(d**2 + rEarth**2 - 2*d*rEarth*np.cos(np.radians(l))*np.cos(np.radians(b)))
    
    def get_primed_coords(self, d: float, # distance from Sun in kpc
                      l: float = l, # galactic longitude in degrees
                      b: float = b, # galactic latitude in degrees
                      )-> tuple:
        """Get galactocentric coordinates x', y' given galactic latitude and longitude l, b, and distance d
        """
        # convert angles from degrees to radians
        l_rad = np.deg2rad(l)
        b_rad = np.deg2rad(b)
        alpha_rad = np.deg2rad(alphabar)

        # calculate unrotated Cartesian coordinates
        x_unrot = rEarth - d * np.cos(b_rad) * np.cos(l_rad)
        y_unrot = d * np.cos(b_rad) * np.sin(l_rad)

        # rotate the coordinates
        x_prime = x_unrot * np.cos(alpha_rad) - y_unrot * np.sin(alpha_rad)
        y_prime = x_unrot * np.sin(alpha_rad) + y_unrot * np.cos(alpha_rad)

        z_prime = d * np.sin(b_rad)

        return x_prime, y_prime, z_prime
    

    # Add Koshimoto Parametric MW Model
    # https://iopscience.iop.org/article/10.3847/1538-4357/ac07a8/pdf

    def zthin(self, r):
        if r > 4.5:
            return zthinSol - (zthinSol - zthin45) * (rsol - r) / (rsol - 4.5)
        else:
            return zthin45

    def rho_thin(self, r, z) -> float:
        if r > rdBreak:
            result = rho_thin_Sol * zthinSol / self.zthin(r) * \
                np.exp(-((r - rsol) / rthin)) * \
                (1 / np.cosh(-np.abs(z) / self.zthin(r)))**2
        else:
            result = rho_thin_Sol * zthinSol / self.zthin(r) * \
                np.exp(-((rdBreak - rsol) / rthin)) * \
                (1 / np.cosh(-np.abs(z) / self.zthin(r)))**2
        
        return result 
    
    def rho_thick(self, r, z) -> float:
        if r > rdBreak:
            result = rho_thick_Sol * np.exp(-((r - rsol) / rthick)) * \
                np.exp(-(np.abs(z) / zthickSol))
        else:
            result = rho_thick_Sol * np.exp(-((rdBreak - rsol) / rthick)) * \
                np.exp(-(np.abs(z) / zthickSol))

        return result 

    
    # Bulge Density
    def rsf(self, xp, yp, zp):
        rs = (((xp/x0)**cperp + (yp/y0)**cperp)**(cpar/cperp) + (zp/z0)**cpar)**(1/cpar)
        return rs
    
    def fE(self, xp, yp, zp):
        return np.exp(-self.rsf(xp, yp, zp))
    
    def cut(self, x):
        if x > 0:
            return np.exp(-x**2)
        else:
            return 1
        
    def rho_bulge(self, d) -> float:
        xp, yp, zp = self.get_primed_coords(d)
        xp, yp, zp = abs(xp), abs(yp), abs(zp)
        r = (xp**2 + yp**2 + zp**2)**0.5
        return rho0_B * self.fE(xp, yp, zp) * self.cut((r - Rc) / 0.5)

    def density_stars(self, d) -> float:
        r = self.dist_center(d)
        _, _, z = self.get_primed_coords(d)
        return (self.rho_thin(r, z) + self.rho_thick(r, z) + self.rho_bulge(d))

    def density_dm(self, r: float, # distance to MW center in kpc
                ) -> float: # DM density in Msun/kpc^3
        return rhoc / ((r/rs) * (1 + r/rs)**2)
    
    def velocity_dispersion_stars(self, r, v_c: float = 30):
        return v_c


# %% ../nbs/08_galaxy.ipynb 7
class M31Model(Galaxy):
    def __init__(self, parameters):
        super().__init__(parameters)

    def dist_center(self, d):
        return dsM31 - d
        
    def einasto(self, a, rhoc, dn, ac, n):
        return rhoc * np.exp(-dn *((a/ac)**(1/n) - 1))

    def calculate_a(self, d, q, i):
        z = d * np.sin(i)
        r = d * np.cos(i)
        return (r**2 + z**2/q**2)**0.5

    def density_component(self, d, q, rhoc, dn, ac, n):
        i = np.deg2rad(90-77)
        a = self.calculate_a(d, q, i)
        return self.einasto(a, rhoc, dn, ac, n)

    def rho_bulge(self, d) -> float:
        return self.density_component(d, q=0.72, rhoc=9.201e-1 * (1e3)**3, dn=7.769, ac=1.155, n=2.7)

    def rho_disk(self, d) -> float:
        return self.density_component(d, q=0.17, rhoc=1.307e-2 * (1e3)**3, dn=3.273, ac=10.67, n=1.2)

    def rho_nucleus(self, d) -> float:
        return self.density_component(d, q=0.99, rhoc=1.713 * (1e3)**3, dn=11.668, ac=0.0234, n=4.0)

    def density_stars(self, d: float) -> float:
        #Only use disk density since bulge and nucleus are mostly blocked out in HSC survey
        if self.use_max_density:
            return self.rho_disk(d) * 1.5
        return self.rho_disk(d)

    def density_dm(self, r: float) -> float:
        return rhocM31 / ((r/rsM31) * (1 + r/rsM31)**2)
    
    def velocity_dispersion_stars(self, r, v_c: float = 60) -> float:
        return v_c

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_ffp.ipynb.

# %% auto 0
__all__ = ['options', 'dGdt_FFP', 'Ffp']

# %% ../nbs/01_ffp.ipynb 3
from .parameters import *
from .utils import *
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import nquad
from scipy.interpolate import interp1d


# %% ../nbs/01_ffp.ipynb 6
options = {"epsabs": 1e-10, "epsrel": 1e-10}

def dGdt_FFP(t, mFFP):
    def integrand(umin, d):
        return 1 / (ut**2 - umin**2)**(1/2) * rho_FFPs(d) / \
               (mFFP * velocity_dispersion(d)**2) * velocity_radial(d, mFFP, umin, t * htosec)**4 * \
               (htosec / kpctokm)**2 * np.exp(-velocity_radial(d, mFFP, umin, t * htosec)**2 / velocity_dispersion(d)**2)
    result, _ = nquad(integrand, [(0, ut), (0, rEarth)], opts=options)
    return 2 * result

# %% ../nbs/01_ffp.ipynb 8
class Ffp:
    
    def __init__(self, 
                 mlow: float, # lower mass limit in solar masses
                 alpha: float, # power law slope of distribution
                 n_ffp: float = int(1e4), # number of FFPs
                 ): 
        self.mlow = mlow
        self.alpha = alpha
        self.n_ffp = n_ffp
        self.sample_masses = self.generate_sample(self.n_ffp)
        self.tE_interp = None
    
    def __str__(self):
        return f"FFP: mlow={self.mlow}, alpha={self.alpha}, n_ffp={self.n_ffp}"
    __repr__ = __str__

    def generate_sample(self, 
                        n: int = int(1e4) # number of samples
                        ):
        return self.mlow * (1 - np.random.rand(int(n)))**(-1 / (self.alpha - 1))
    
    def differential_rate(self,
                          t: float, # crossing time in hours
                          ):
        pass
        # Perform weighted sum here

    def get_ffp_pdf(self,
                    n_bins: int = 10, # number of mass bins
                    ):
        
        bins = np.logspace(np.log10(self.mlow), np.log10(np.max(self.sample_masses) * 1.01), num=n_bins)
        counts, hist_bins, = np.histogram(self.sample_masses, bins=bins, density=True)
        bin_centers = (hist_bins[1:] + hist_bins[:-1]) / 2
        ffpPDF = np.zeros((len(counts), len(bin_centers)))
        ffpPDF[0] = counts/np.sum(counts)
        ffpPDF[1] = bin_centers
        return ffpPDF
    
    def get_weighted_te(self,
                        n_bins: int = 10, # number of mass bins
                        ):
        ffpPDF = self.get_ffp_pdf(n_bins)
        tMin = 1e-2  # hours
        tMax = 1e3
        n_t_bins = 10
        tBins = np.logspace(np.log10(tMin), np.log10(tMax), num=n_t_bins)

        tETable = np.zeros((len(ffpPDF[0])-1, len(tBins)))
        for i in range(len(ffpPDF[0])-1):
            for j in range(len(tBins)):
                tETable[i,j] = ffpPDF[0][i] * dGdt_FFP(tBins[j], ffpPDF[1][i])

        tEWeighted = np.sum(tETable, axis=0)
        # tEInterp = interp1d(np.log10(tBins), np.log10(tEWeighted), kind="cubic")
        return tBins, tEWeighted
    
    def make_te_interp(self,
                       n_bins: int = 10, # number of mass bins
                       ):
        tBins, tEWeighted = self.get_weighted_te(n_bins)
        tEInterp = interp1d(np.log10(tBins), np.log10(tEWeighted), kind="cubic")
        self.tE_interp = tEInterp
    
    def differential_rate(self, t):
        if self.tE_interp is None:
            self.make_te_interp()
        return 10**self.tE_interp(np.log10(t))



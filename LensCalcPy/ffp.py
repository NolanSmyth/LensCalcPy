# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_ffp.ipynb.

# %% auto 0
__all__ = ['m_low_ffp_interp', 'm_high_interp', 'alpha_low_interp', 'alpha_high_interp', 'zthin', 'rho_thin', 'rho_thick', 'rsf',
           'fE', 'cut', 'rho_bulge', 'rho_FFPs_mw', 'm_avg_ffp', 'make_m_avg_interp', 'FfpPopulation']

# %% ../nbs/01_ffp.ipynb 3
from .parameters import *
from .utils import *
from .lens import *

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import nquad, dblquad
from scipy.interpolate import interp1d, interp2d
import pickle
import functools
from pathos.multiprocessing import ProcessingPool as Pool


# %% ../nbs/01_ffp.ipynb 5
with open('../interpolations/m_avg_interp.pkl', 'rb') as f:
    m_avg_interp = pickle.load(f)

# Disk Density
def zthin(r):
    if r > 4.5:
        return zthinSol - (zthinSol - zthin45) * (rsol - r) / (rsol - 4.5)
    else:
        return zthin45

def rho_thin(r, 
             z,
            n_ffp: float = 1, # number of FFPs per star
            m_low: float = 1e-6, # mass of FFP in Msun
            alpha: float = 2, # power law index of FFP mass function):
            ) -> float: # FFP density in Msun/kpc^3
    #? Is averaging over mass correct here?
    mass_avg = m_avg_interp(m_low, alpha)

    if r > rdBreak:
        result = rho_thin_Sol * zthinSol / zthin(r) * \
            np.exp(-((r - rsol) / rthin)) * (1 / np.cos(np.abs(z) / zthin(r)))**2
    else:
        result = rho_thin_Sol * zthinSol / zthin(r) * \
            np.exp(-((rdBreak - rsol) / rthin)) * (1 / np.cos(np.abs(z) / zthin(r)))**2
    
    return result * n_ffp * mass_avg

def rho_thick(r, 
              z, 
            n_ffp: float = 1, # number of FFPs per star
            m_low: float = 1e-6, # mass of FFP in Msun
            alpha: float = 2, # power law index of FFP mass function):
            ) -> float: # FFP density in Msun/kpc^3
    #? Is averaging over mass correct here?
    mass_avg = m_avg_interp(m_low, alpha)
    
    if r > rdBreak:
        result = rho_thick_Sol * np.exp(-((r - rsol) / rthick)) * \
            np.exp(-(np.abs(z) / zthickSol))
    else:
        result = rho_thick_Sol * np.exp(-((rdBreak - rsol) / rthick)) * \
            np.exp(-(np.abs(z) / zthickSol))

    return result * n_ffp * mass_avg

# Bulge Density
def rsf(xp, yp, zp):
    R = (xp**cperp / x0**cperp + yp**cperp / y0**cperp)**(cpar/cperp) + (zp / z0)**cpar
    return R**(1/cpar)

def fE(xp, yp, zp):
    return np.exp(-rsf(xp, yp, zp))

def cut(x):
    if x > 0:
        return np.exp(-x**2)
    else:
        return 1

def rho_bulge(d: float,
            n_ffp: float = 1, # number of FFPs per star
            m_low: float = 1e-6, # mass of FFP in Msun
            alpha: float = 2, # power law index of FFP mass function):
            ) -> float: # FFP density in Msun/kpc^3
    #? Is averaging over mass correct here?
    mass_avg = m_avg_interp(m_low, alpha)
    xp, yp = get_primed_coords(d)
    #todo need to generalize this to arbitrary z
    zp = 0
    R = (xp**2 + yp**2 + zp**2)**0.5
    return rho0_B * fE(xp, yp, zp) * cut((R - Rc) / 0.5) * n_ffp * mass_avg

# Total FFP Density
def rho_FFPs_mw(d: float, # distance from Sun in kpc
             n_ffp: float = 1, # number of FFPs per star
             m_low: float = 1e-6, # lowest mass of FFP in Msun
             alpha: float = 2, # power law index of FFP mass function
             ) -> float: # FFP density in Msun/kpc^3
    r = dist_mw(d)
    z = 0
    return (rho_thin(r, z, n_ffp, m_low, alpha) + rho_thick(r, z, n_ffp, m_low, alpha ) + rho_bulge(d, n_ffp, m_low, alpha)) 

def m_avg_ffp(m_low, alpha):
    masses = m_low * (1 - np.random.rand(int(1e4)))**(-1 / (alpha - 1))
    masses[masses > m_high_interp] = m_high_interp
    return np.mean(masses)

m_low_ffp_interp = 1e-15
m_high_interp = 1e0
alpha_low_interp = 1
alpha_high_interp = 3

def make_m_avg_interp(n_points=40):
    alpha_arr = np.linspace(alpha_low_interp, alpha_high_interp, n_points)
    m_arr = np.logspace(np.log10(m_low_interp), np.log10(m_high_interp), n_points) #solar masses

    def calc_m_avg_arr(m):
    # Calculate ut_arr for the current m
        return np.array([m_avg_ffp(m, alpha) for alpha in alpha_arr])
    
    with Pool() as p:
        m_avg_values = list(p.map(calc_m_avg_arr, m_arr))

    # Convert ut_values to a 2D array
    m_avg_values = np.array(m_avg_values)
    
    # Create the 2D interpolation table
    m_avg_interp = interp2d(m_arr, alpha_arr, m_avg_values)
    return m_avg_interp

# %% ../nbs/01_ffp.ipynb 8
with open('../interpolations/ut_interp_m31.pkl', 'rb') as f:
    ut_interp = pickle.load(f)
    
# def differential_rate_integrand_mw_ffp(umin, d, t, m_ffp, finite=False ):
#         r = dist_mw(d)
#         ut = ut_interp(d, m_ffp)[0] if (ut_interp and finite) else 1
#         if ut <= umin:
#             return 0
#         v_rad = velocity_radial(d, m_ffp, umin, t * htosec, ut)
#         v_disp = velocity_dispersion_mw(r)
#         return 2 * (1 / (ut**2 - umin**2)**0.5 *
#                 rho_FFPs_mw(d) / (m_ffp * v_disp**2) *
#                 v_rad**4 * (htosec / kpctokm)**2 *
#                 np.exp(-(v_rad**2 / v_disp**2)))

# def umin_lower_bound(d):
#     return 0

# def dGdt_FFP(t, m_ffp, finite=False):
#         if finite:
#             def umin_upper_bound(d):
#                 return ut_interp(d, m_ffp)[0]
            
#             f = functools.partial(differential_rate_integrand_mw_ffp, m_ffp=m_ffp)
#             result, error = dblquad(f, 0, ds, umin_lower_bound, umin_upper_bound, args=(t,))
#             return result    

#         else:
#             umin_bounds = [0, ut]
#             d_bounds = [0, ds]
#             f = functools.partial(differential_rate_integrand_mw_ffp, m_ffp=m_ffp)
#             result, error = nquad(f, [umin_bounds, d_bounds], args=[t])
#             return result


# %% ../nbs/01_ffp.ipynb 13
class FfpPopulation():
    
    def __init__(self, 
                 mlow: float, # lower mass limit in solar masses
                 alpha: float, # power law slope of distribution
                 n_bins: int = 10, # number of bins to use for the mass distribution
                 ): 
        if alpha < alpha_low_interp or alpha > alpha_high_interp:
            raise ValueError(f"alpha must be between {alpha_low_interp} and {alpha_high_interp}")
        if mlow < m_low_ffp_interp or mlow > m_high_interp:
            raise ValueError(f"mlow must be between {m_low_ffp_interp} and {m_high_interp}")
        self.mlow = mlow
        self.alpha = alpha
        self.sample_masses = self.generate_sample(int(1e4))
        self.tE_interp = None
        self.tE_finite_interp = None
        self.ut_interp = ut_interp
        self.n_bins = n_bins
        self.ffps = []
        self.ffp_weights = [] #relative contribution of each FFP mass bin

        self.generate_ffps()
    
    def __str__(self):
        return f"FFP: mlow={self.mlow}, alpha={self.alpha}, n_bins={self.n_bins}"
    __repr__ = __str__

    def generate_ffps(self):
        bins = np.logspace(np.log10(self.mlow), np.log10(np.max(self.sample_masses) * 1.01), num=self.n_bins)
        counts, hist_bins, = np.histogram(self.sample_masses, bins=bins, density=True)
        bin_centers = (hist_bins[1:] + hist_bins[:-1]) / 2
        weights = counts/np.sum(counts)
        masses = bin_centers
        for mass in masses:
            self.ffps.append(Ffp(mass))
        for weight in weights:
            self.ffp_weights.append(weight)

    def get_weighted_te(self,
                        finite=False,
                        ):
        tMin = 1e-2  # hours
        tMax = 1e3
        n_t_bins = 10
        tBins = np.logspace(np.log10(tMin), np.log10(tMax), num=n_t_bins)

        tETable = np.zeros((len(self.ffps)-1, len(tBins)))
        for i in range(len(self.ffps)-1):
            for j in range(len(tBins)):
                tETable[i,j] = self.ffp_weights[i] * self.ffps[i].differential_rate_mw(tBins[j], finite=finite)

        tEWeighted = np.sum(tETable, axis=0)
        return tBins, tEWeighted

    def generate_sample(self, 
                        n: int = int(1e4) # number of samples
                        ):
        masses = self.mlow * (1 - np.random.rand(int(n)))**(-1 / (self.alpha - 1))
        masses[masses > m_high_interp] = m_high_interp
        return masses

    def make_te_interp(self,
                       finite = False,
                       ):
        tBins, tEWeighted = self.get_weighted_te(finite=finite)
        # Handle zero values in tEWeighted
        eps = 1e-50
        tEWeighted_nonzero = np.where(tEWeighted == 0, eps, tEWeighted)
        tEInterp = interp1d(np.log10(tBins), np.log10(tEWeighted_nonzero), kind="cubic")

        if finite:
            self.tE_finite_interp = tEInterp
        else:
            self.tE_interp = tEInterp

    def differential_rate_total(self, t, finite=False):
        if finite:
            if self.tE_finite_interp is None:
                self.make_te_interp(finite=finite)
            return 10**self.tE_finite_interp(np.log10(t))
    
        if self.tE_interp is None:
            self.make_te_interp(finite=finite)
        return 10**self.tE_interp(np.log10(t))

    def compute_differential_rate(self, ts, finite=False):
        return [self.differential_rate_total(t, finite=finite) for t in ts]

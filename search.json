[
  {
    "objectID": "galaxy.html",
    "href": "galaxy.html",
    "title": "galaxy",
    "section": "",
    "text": "The autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n\n\n\nsource\n\nGalaxy\n\n Galaxy (parameters)\n\nHelper class that provides a standard way to create an ABC using inheritance.\n\nsource\n\n\nMilkyWayModel\n\n MilkyWayModel (parameters)\n\nHelper class that provides a standard way to create an ABC using inheritance.\n\nsource\n\n\nM31Model\n\n M31Model (parameters)\n\nHelper class that provides a standard way to create an ABC using inheritance.\n\nmw_model = MilkyWayModel(mw_parameters)\nm31_model = M31Model(m31_parameters)\n\n\nmw_model.density_stars(0,1,1)*1e-9\n\n0.041460100749342\n\n\n\ntest_eq(mw_model.zthin(4.5), zthin45)\n\n\nd_arr = np.logspace(np.log10(1), np.log10(ds), num=1000)\nz_arr = [d * np.sin(np.deg2rad(b)) for d in d_arr]\n\n# Calculate the density values for each component\nrho_total_arr = [mw_model.density_stars(i) for i in d_arr]\nrho_bulge_arr = [mw_model.rho_bulge(mw_model.dist_center(d_arr[i], l=l, b=b), z_arr[i]) for i in range(len(d_arr))]\nrho_thin_arr = [mw_model.rho_thin(mw_model.dist_center(d_arr[i], l=l, b=b), z_arr[i]) for i in range(len(d_arr))]\nrho_thick_arr = [mw_model.rho_thick(mw_model.dist_center(d_arr[i], l=l, b=b), z_arr[i]) for i in range(len(d_arr))]\nrho_dm_arr = [mw_model.density_dm(d_arr[i]) for i in range(len(d_arr))]\n\nplt.plot(d_arr, rho_total_arr, label=\"Total\")\nplt.plot(d_arr, rho_bulge_arr, label=\"Bulge\")\nplt.plot(d_arr, rho_thin_arr, label=\"Thin Disk\")\nplt.plot(d_arr, rho_thick_arr, label=\"Thick Disk\")\nplt.plot(d_arr, rho_dm_arr, label=\"DM\")\n\nplt.xlabel(r\"$d$ [kpc]\", fontsize=16)\nplt.ylabel(r\"$\\rho$ [M$_\\odot$/$\\mathrm{kpc}^3$]\", fontsize=16)\nplt.title('MW, LoS: l = {}, b = {}'.format(l, b), fontsize=16)\nplt.legend(fontsize=14)\n\nplt.yscale(\"log\")\nplt.xscale(\"log\")\nplt.xlim(1e0, ds)\nplt.ylim(1e3, 1e10)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n# Calculate the density values for each component\nrho_total_arr = [m31_model.density_stars(d) for d in d_arr]\nrho_bulge_arr = [m31_model.rho_bulge(m31_model.dist_center(d)) for d in d_arr]\nrho_disk_arr = [m31_model.rho_disk(m31_model.dist_center(d)) for d in d_arr]\nrho_nucleus_arr = [m31_model.rho_nucleus(m31_model.dist_center(d)) for d in d_arr]\nrho_dm_arr = [m31_model.density_dm(d) for d in d_arr] # Assuming you have a method density_dm in M31Model\n\nplt.plot(d_arr, rho_bulge_arr, label=\"Bulge\")\nplt.plot(d_arr, rho_disk_arr, label=\"Disk\")\nplt.plot(d_arr, rho_nucleus_arr, label=\"Nucleus\")\nplt.plot(d_arr, rho_dm_arr, label=\"DM\")\nplt.plot(d_arr, rho_total_arr, label=\"Total\", ls=\"--\")\n\n\nplt.xlabel(r\"$a$ [kpc]\", fontsize=16)\nplt.ylabel(r\"$\\rho$ [M$_\\odot$/$\\mathrm{kpc}^3$]\", fontsize=16)\nplt.title('M31, LoS: l = {}, b = {}'.format(l,b), fontsize=16)\n\nplt.legend(fontsize=14)\n\nplt.yscale(\"log\")\n# plt.xlim(1e1, ds)\nplt.xlim(765, 770)\nplt.ylim(1e7, 1e9)\n\n\nplt.show()\n\n/var/folders/qd/09mj47cx551c65glw6y47d6r0000gn/T/ipykernel_63567/961728720.py:48: RuntimeWarning: divide by zero encountered in double_scalars\n  return rhocM31 / ((r/rsM31) * (1 + r/rsM31)**2)\n\n\n\n\n\n\n\n\n\n\n# Calculate the density values for each component using the methods from the classes\nrho_ffp_mw = [mw_model.density_stars(d) for d in d_arr]\nrho_ffp_m31 = [m31_model.density_stars(d) for d in d_arr]\nrho_dm_mw = [mw_model.density_dm(d) for d in d_arr]\nrho_dm_m31 = [m31_model.density_dm(d) for d in d_arr] # Assuming you have a method density_dm in M31Model\n\nplt.plot(d_arr, rho_ffp_mw, label=\"MW FFPs\", color=\"blue\")\nplt.plot(d_arr, rho_dm_mw, label=\"MW DM\", color=\"blue\", linestyle=\"--\")\nplt.plot(d_arr, rho_ffp_m31, label=\"M31 FFPs\", color=\"red\")\nplt.plot(d_arr, rho_dm_m31, label=\"M31 DM\", color=\"red\", linestyle=\"--\")\n\nplt.xlabel(r\"$d$ [kpc]\", fontsize=16)\nplt.ylabel(r\"$\\rho$ [M$_\\odot$/$\\mathrm{kpc}^3$]\", fontsize=16)\nplt.title('LoS: l = {}, b = {}'.format(l, b), fontsize=16)\n\nplt.legend(fontsize=14)\n\nplt.yscale(\"log\")\nplt.xlim(1e0, ds)\nplt.ylim(1e-10, 1e10)\n\nplt.show()\n\n/var/folders/qd/09mj47cx551c65glw6y47d6r0000gn/T/ipykernel_5639/961728720.py:48: RuntimeWarning: divide by zero encountered in double_scalars\n  return rhocM31 / ((r/rsM31) * (1 + r/rsM31)**2)",
    "crumbs": [
      "galaxy"
    ]
  },
  {
    "objectID": "survey.html",
    "href": "survey.html",
    "title": "survey",
    "section": "",
    "text": "The autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n\n\n\nsource\n\nSurvey\n\n Survey (l:float, b:float, source_dist:float, obs_time:float,\n         cadence:float, survey_area:float, n_sources:int,\n         efficiency:&lt;function &lt;lambda&gt;&gt;, use_mw_source:bool=False,\n         mw_model:LensCalcPy.galaxy.MilkyWayModel=None,\n         m31_model:LensCalcPy.galaxy.M31Model=None, A_t:float=1.34)\n\nA class to represent a survey.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nl\nfloat\n\nGalactic longitude in degrees\n\n\nb\nfloat\n\nGalactic latitude in degrees\n\n\nsource_dist\nfloat\n\nDistance to observation source in kpc\n\n\nobs_time\nfloat\n\nObservation time in hours\n\n\ncadence\nfloat\n\nCadence in hours\n\n\nsurvey_area\nfloat\n\nSurvey area in deg^2\n\n\nn_sources\nint\n\nNumber of sources observed in survey\n\n\nefficiency\n\n\nEfficiency of survey\n\n\nuse_mw_source\nbool\nFalse\nUse Milky Way as source\n\n\nmw_model\nMilkyWayModel\nNone\n\n\n\nm31_model\nM31Model\nNone\n\n\n\nA_t\nfloat\n1.34\nThreshold magnification for detection\n\n\n\n\n\nEfficiency Estimation\n\nm_pbh = 1e-5\nf_dm = 1\np = 1\n\ns1 = Survey(l, b, ds, obs_time, survey_area, n_sources=n_sources, survey_area=survey_area, efficiency=lambda t: 0.6, A_t = 1.1)\ns2 = Survey(l, b, ds, obs_time, survey_area, n_sources=n_sources, survey_area=survey_area, efficiency=lambda t: 0.6, A_t = 1.34)\n# s.add_pbh(m_pbh, f_dm)\ns1.add_ffp(p)\ns2.add_ffp(p)\n\n\nt_es = np.logspace(-2, 2, 10)\nffp_rates1 = s1.get_crossing_times_rates_ffp(t_es, finite=False)\nffp_rates2 = s2.get_crossing_times_rates_ffp(t_es, finite=False)\n\n\n# plt.loglog(t_es, pbh_rates, label=\"PBH\")\nplt.loglog(t_es, ffp_rates1, label=f\"A_t = {s1.A_t:.2f}\")\nplt.loglog(t_es, ffp_rates2, label=f\"A_t = {s2.A_t:.2f}\", linestyle=\"--\")\n\nplt.xlabel(r\"$t_E$ [h]\", fontsize=16)\nplt.ylabel(r\"$d\\Gamma/dt$ [events/star/hr/hr]\", fontsize=16)\nplt.title(\"Point Source Event Rates\", fontsize=16)\n\nplt.xlim(1e-2, 1e3)\n# plt.ylim(1e-25, 1e-7)\n\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n# plt.loglog(t_es, pbh_rates, label=\"PBH\")\nplt.loglog(t_es, ffp_rates1, label=\"A_t = {s1.A_t:.2f}\")\nplt.loglog(t_es, ffp_rates2, label=\"A_t = {s2.A_t:.2f}\")\n\nplt.xlabel(r\"$t_E$ [h]\", fontsize=16)\nplt.ylabel(r\"$d\\Gamma/dt$ [events/star/hr/hr]\", fontsize=16)\n\nplt.xlim(1e-2, 1e3)\n# plt.ylim(1e-25, 1e-7)\n\nplt.legend()\nplt.show()",
    "crumbs": [
      "survey"
    ]
  },
  {
    "objectID": "lens.html",
    "href": "lens.html",
    "title": "lens",
    "section": "",
    "text": "source\n\nLens\n\n Lens (mass, u_t=1, ds=770)\n\nAbstract class for lens objects.",
    "crumbs": [
      "lens"
    ]
  },
  {
    "objectID": "ffp.html",
    "href": "ffp.html",
    "title": "ffp",
    "section": "",
    "text": "source\n\nFfp\n\n Ffp (p:float=1, m_min:float=1e-15, m_max:float=0.001,\n      mw_model:LensCalcPy.galaxy.MilkyWayModel=None,\n      m31_model:LensCalcPy.galaxy.M31Model=None, l=None, b=None, u_t=1,\n      ds=770)\n\nA class to represent a PBH population\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\np\nfloat\n1\nMass function power law index\n\n\nm_min\nfloat\n1e-15\nMinimum mass in Msun\n\n\nm_max\nfloat\n0.001\nMaximum mass in Msun\n\n\nmw_model\nMilkyWayModel\nNone\n\n\n\nm31_model\nM31Model\nNone\n\n\n\nl\nNoneType\nNone\nGalactic longitude\n\n\nb\nNoneType\nNone\nGalactic latitude\n\n\nu_t\nint\n1\nthreshold impact parameter in point-source limit\n\n\nds\nint\n770\n\n\n\n\n\np = 1.0\n# f = Ffp(p, l = 1.0, b = -1.03, ds=8.5, u_t = 2)\n# f = Ffp(0, l = 1.0, b = -1.03, ds=8.5, u_t = 1, m_min=2.5e-6, m_max=3.5e-6)\nf = Ffp(0, l = l, b = b, ds=ds, u_t = 1)\n\n\nf.differential_rate_mw(1e-1, finite=True, v_disp=220, t_fwhm=False)\n\n3.0996682206844185e-15\n\n\n\nf.differential_rate_mw(10, finite=True, v_disp=220, t_fwhm=True)\n\n2.0418395865633797e-15\n\n\n\nf.differential_rate_m31_mass_new(3e-4, finite=True, v_disp=None, tcad=0.07, tobs=3, epsabs = 1.49e-08, epsrel = 1.49e-08, efficiency=None, monochromatic=True, t_fwhm=True)\n\n3.580189123211615e-15\n\n\n\nf.differential_rate_m31_mass_new(3e-4, finite=False, v_disp=None, tcad=0.07, tobs=3, epsabs = 1.49e-08, epsrel = 1.49e-08, efficiency=None, monochromatic=True, t_fwhm=True)\n\n8.367673014152553e-14\n\n\n\nf.differential_rate_mw_mass_new(1e-11, finite=True, v_disp=None, tcad=0.07, tobs=3, epsabs = 1.49e-08, epsrel = 1.49e-08, efficiency=None, monochromatic=True, t_fwhm=False)\n\n7.2026805885836655e-28\n\n\n\nf.differential_rate_mw_mass_new(1e-21, finite=False, v_disp=None, tcad=0.07, tobs=3, epsabs = 1.49e-08, epsrel = 1.49e-08, efficiency=None, monochromatic=True, t_fwhm=True)\n\n9.858671258336687e-38\n\n\n\nf.differential_rate_mw_mass(1e-11, finite=True, v_disp=None, tcad=0.07, tobs=3, epsabs = 1.49e-08, epsrel = 1.49e-08, efficiency=None, monochromatic=True)\n\n7.202977965554305e-28\n\n\n\n#Test that the mass function is normalized correctly\ntest_close(abs(nquad(f.mass_func,[[np.log10(f.m_min), np.log10(f.m_max)]], opts={'points': [f.m_min, f.m_min*1e3, f.m_min*1e5]})[0]), 1, eps=1e-3)\n\n\n#Test that the mass function is normalized correctly\ntest_close(abs(nquad(f.f_m,[[f.m_min, f.m_max]], opts={'points': [f.m_min, f.m_min*1e3, f.m_min*1e6, f.m_max]})[0]), 1, eps=1e-3)",
    "crumbs": [
      "ffp"
    ]
  },
  {
    "objectID": "lightcurves.html",
    "href": "lightcurves.html",
    "title": "lightcurves",
    "section": "",
    "text": "#Nothing implemented yet, just a dump for future work\n\ndef A_ps(u):\n    return (u**2 + 2) / (u * (u**2 + 4)**(1/2))\n\ndef f_func(x):\n    return (2 + x)/(x*(4+x))**(0.5) - 1\n\ndef t_fwhm_gondolo(t_e, umin):\n    deltab = f_func(umin**2)\n    bw2 = 2* f_func(deltab)\n    w_b = 2*(bw2 - umin**2)**(1/2)\n    return w_b * t_e\n\ndef t_E_from_t_fwhm(t_fwhm, umin):\n    deltab = f_func(umin**2)\n    bw2 = 2* f_func(deltab)\n    w_b = 2*(bw2 - umin**2)**(1/2)\n    return t_fwhm / w_b\n\ndef ellip(phi, m):\n    return quad(lambda x: np.sqrt(1 - m**2*np.sin(x)**2), 0, phi)[0]\n\ndef theta_max(u, rho):\n    if u &lt;= rho:\n        return np.pi/2\n    else:\n        return np.arcsin(rho/u)\n\ndef A_gould(u, rho):\n    return A_ps(u) * 4*u / (np.pi * rho) * ellip(theta_max(u, rho), u/rho)\n\ndef f_func_finite(u, rho):\n    return A_gould(u, rho) - 1\n\ndef t_fwhm_gondolo(t_e, umin):\n    deltab = f_func(umin**2)\n    bw2 = 2* f_func(deltab)\n    w_b = 2*(bw2 - umin**2)**(1/2)\n    return w_b * t_e\n\ndef t_fwhm_gondolo_finite(t_e, umin, rho):\n    func = lambda b: f_func_finite(b,rho) - f_func_finite(umin**2,rho)*0.5\n    bw = fsolve(func,1)[0]\n    w_b = 2*(bw**2 - umin**2)**(1/2)\n    return w_b * t_e\n\n# def t_E_from_t_fwhm_finite(t_fwhm, umin, rho):\n#     if rho &gt;=10:\n#         return t_fwhm/rho/2\n#     func = lambda b: f_func_finite(b,rho) - f_func_finite(umin**2,rho)*0.5\n#     bw = fsolve(func,1)[0]\n#     w_b = 2*(bw**2 - umin**2)**(1/2)\n#     return t_fwhm / w_b\n\ndef t_E_from_t_fwhm_finite(t_fwhm, umin, rho):\n    if rho &gt;=1:\n        return t_fwhm/rho/2\n    return t_E_from_t_fwhm(t_fwhm, umin)\n\ndef magnification_finite_new(u, rho):\n    integrand = lambda r, theta: integrand_polar(r, theta, u)\n    result, _ = nquad(integrand, [[0, rho], [0, 2 * np.pi]])\n    return result / (np.pi * rho**2)\n    \ndef u_fwhm_func(rho, umin):\n    Amax = magnification_finite_new(umin, rho)\n    func = lambda u: magnification_finite_new(u, rho) - (1+(1-Amax)/2)\n    return fsolve(func, 1, xtol=1e-2)[0]\n\ndef t_duration(t_e, umin, finite, rho=None, ut=1):\n    if not finite:\n        return 2*(ut**2 - umin**2)**(1/2) * t_e\n    else:\n        if ut_func_new(rho, 1.34)[0] &lt;= umin:\n            return 0\n        return (2*(ut_func_new(rho, 1.34)**2 - umin**2)**(1/2) * t_e)[0]\n\n\nu_vals = np.logspace(-2, 1, 30)\nrho_vals = np.logspace(-2, 1, 30)\nz_vals = np.array([[magnification_finite_new(u, rho) for u in u_vals] for rho in tqdm(rho_vals)])\nmag_finite_interp = RegularGridInterpolator((rho_vals, u_vals), z_vals, method='linear', bounds_error=False, fill_value=None)\n\ndef fast_magnification_finite_new(u, rho):\n    return mag_finite_interp([float(rho), float(u)])\n    \ndef fast_u_fwhm_func(rho, umin):\n    Amax = fast_magnification_finite_new(umin, rho)\n    if Amax&lt;1:\n        return 0\n    func = lambda u: fast_magnification_finite_new(u, rho) - (1+(Amax-1)/2)\n    return fsolve(func, 1)\n\n# z_u_vals = np.array([[fast_u_fwhm_func(rho, u) for u in u_vals] for rho in tqdm(rho_vals)])\n# u_fwhm_interp = RegularGridInterpolator((rho_vals, u_vals), z_u_vals, method='linear', bounds_error=False, fill_value=None)\n\n100%|██████████| 30/30 [01:54&lt;00:00,  3.81s/it]\n\n\n\nz_u_vals = np.array([[fast_u_fwhm_func(rho, u) for u in u_vals] for rho in tqdm(rho_vals)])\nu_fwhm_interp = RegularGridInterpolator((rho_vals, u_vals), z_u_vals, method='linear', bounds_error=False, fill_value=None)\n\n  0%|          | 0/30 [00:00&lt;?, ?it/s]/Users/nolansmyth/opt/anaconda3/lib/python3.9/site-packages/scipy/optimize/_minpack_py.py:177: RuntimeWarning: The iteration is not making good progress, as measured by the \n  improvement from the last ten iterations.\n  warnings.warn(msg, RuntimeWarning)\n100%|██████████| 30/30 [00:00&lt;00:00, 38.77it/s]\n\n\n\ndef t_fwhm(t_e, umin, finite, rho=None, ut=1):\n    if not finite:\n        return t_fwhm_gondolo(t_e, umin)\n    else:\n        Amax = 1 + 1/rho\n        u_fwhm = u_fwhm_interp([rho, umin])[0]\n        if u_fwhm&lt;=umin:\n            return 0\n        return 2*(u_fwhm**2 - umin**2)**(1/2) * t_e\n    \ndef t_e_from_fwhm(t_fwhm, umin, finite, rho=None):\n    if not finite:\n        return t_fwhm / t_fwhm_gondolo(1, umin)\n    else:\n        u_fwhm = u_fwhm_interp([rho, umin])[0]\n        if u_fwhm&lt;=umin:\n            print('u_fwhm&lt;=umin')\n            return 1e-3\n        return t_fwhm / (2*(u_fwhm**2 - umin**2)**(1/2))\n\n\nt_e_from_fwhm\n\n\numin_arr = np.logspace(-1, 0.4, 100)\nrho= 1\nfast_Amax_arr = np.array([fast_magnification_finite_new(umin, rho) for umin in umin_arr])\n\nfast_uhm_arr = np.array([u_fwhm_interp([rho, umin]) for umin in umin_arr])\nut_arr = np.array([ut_func_new(1.2, Amax) for Amax in fast_Amax_arr])\nuhm_arr = np.array([ut_func_new(1.2, 1+(Amax-1)/2) for Amax in fast_Amax_arr])\nuhm_point_arr = np.array([(2* f_func(f_func(umin**2)))**(1/2) for umin in umin_arr])\n\n\n# plt.plot(umin_arr, Amax_arr)\nplt.plot(umin_arr, fast_Amax_arr)\nplt.axhline(1.34, color='k', linestyle='--')\nplt.xlabel(r'$u_{\\rm min}$')\nplt.ylabel(r'$A_{\\rm max}$')\nplt.title(r'$\\rho = $' + str(rho))\nplt.xscale('log')\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.figure(figsize=(10,5))\nplt.subplot(121)\n\nrho= 0.01\nfast_uhm_arr = np.array([u_fwhm_interp([rho, umin])[0] for umin in umin_arr])\nuhm_point_arr = np.array([(2* f_func(f_func(umin**2)))**(1/2) for umin in umin_arr])\nfast_Amax_arr = np.array([fast_magnification_finite_new(umin, rho) for umin in umin_arr])\nut_arr = np.array([ut_func_new(rho, Amax) for Amax in fast_Amax_arr])\nplt.plot(umin_arr, fast_uhm_arr, label='uhm finite')\nplt.plot(umin_arr, uhm_point_arr, label='uhm point', linestyle='--')\nplt.plot(umin_arr, ut_arr, label='ut')\n\nplt.xlabel(r'$u_{min}$')\nplt.ylabel(r'$u_{hm}$')\nplt.title(r'$\\rho = $ ' + str(rho))\nplt.xscale('log')\nplt.yscale('log')\nplt.legend()\n\nplt.subplot(122)\nrho= 1.5\nfast_uhm_arr = np.array([u_fwhm_interp([rho, umin])[0] for umin in umin_arr])\nuhm_point_arr = np.array([(2* f_func(f_func(umin**2)))**(1/2) for umin in umin_arr])\nfast_Amax_arr = np.array([fast_magnification_finite_new(umin, rho) for umin in umin_arr])\nut_arr = np.array([ut_func_new(rho, Amax) for Amax in fast_Amax_arr])\nplt.plot(umin_arr, fast_uhm_arr, label='uhm finite')\nplt.plot(umin_arr, uhm_point_arr, label='uhm point', linestyle='--')\nplt.plot(umin_arr, ut_arr, label='ut')\n\nplt.xlabel(r'$u_{min}$')\nplt.title(r'$\\rho = $ ' + str(rho))\nplt.xscale('log')\nplt.yscale('log')\nplt.show()\n\n\n\n\n\n\n\n\n\nrho = 2.1\n# rho = 0.01\n\nut = 1\numin_arr = np.logspace(np.log10(0.01), np.log10(2), 100)\ntfwhm_arr = np.array([t_fwhm(10, umin, True, rho, ut_func_new(rho, 1.34)) for umin in umin_arr])\ntfwhm_arr_point = np.array([t_fwhm(10, umin, False, rho, ut_func_new(rho, 1.34)) for umin in umin_arr])\nt_duration_arr = np.array([t_duration(10, umin, True, rho,  1) for umin in umin_arr])\n\nrho_arr = np.linspace(0.01, 3, 100)\ntfwhm_arr2 = np.array([t_fwhm(10, 0.1, True, rho, ut_func_new(rho, 1.34)) for rho in rho_arr])\ntfwhm_arr_point2 = np.array([t_fwhm(10, 0.1, False, rho, ut_func_new(rho, 1.34)) for rho in rho_arr])\nt_duration_arr2 = np.array([t_duration(10, 0.1, True, rho, 1) for rho in rho_arr])\n\n\nplt.figure(figsize=(10,5))\nplt.subplot(121)\nplt.title('t_e = 10, rho = {}'.format(rho))\n\nplt.plot(umin_arr, tfwhm_arr, label='fwhm finite')\nplt.plot(umin_arr, tfwhm_arr_point, label = 'fwhm point', linestyle='--')\nplt.plot(umin_arr, t_duration_arr, label='duration', linestyle='--')\nplt.ylabel(r'$t$')\nplt.xlabel(r'$u_{\\rm min}$')\n# plt.xscale('log')\nplt.legend()\nplt.subplot(122)\nplt.plot(rho_arr, tfwhm_arr2)\nplt.plot(rho_arr, tfwhm_arr_point2, linestyle='--')\nplt.plot(rho_arr, t_duration_arr2, linestyle='--')\nplt.title(r't_e = 10, u_min = 0.1')\nplt.xlabel(r'$\\rho$')\nplt.show()\n\n\n\n\n\n\n\n\n\ndef u_func(umin, t, t_e):\n    return np.sqrt(umin**2 + (t/t_e)**2)\n\ndef t_fwhm_point(umin, t_e):\n    t_vals = np.linspace(-5*t_e, 5*t_e, 2000)\n    A_vals = np.array([A_ps(u_func(umin, t, t_e)) for t in t_vals])\n    A_max = np.max(A_vals)\n    t_0 = t_vals[np.argmax(A_vals)]\n    half_max_indices = np.where(np.isclose(A_vals, A_max/2, atol=0.1))[0]\n    t_fwhm = t_vals[half_max_indices[-1]] - t_vals[half_max_indices[0]]\n    return t_fwhm\n\n\ndef t_fwhm_finite(umin, t_e, rho):\n    t_vals = np.linspace(-5*t_e, 5*t_e, 2000)\n    A_vals = np.array([A_gould(u_func(umin, t, t_e), rho) for t in t_vals])\n    A_max = np.max(A_vals)\n    t_0 = t_vals[np.argmax(A_vals)]\n    half_max_indices = np.where(np.isclose(A_vals, A_max/2, atol=0.1))[0]\n    t_fwhm = t_vals[half_max_indices[-1]] - t_vals[half_max_indices[0]]\n    return t_fwhm\n\n\numin = 1.2\ndeltab = f_func(umin**2)\nbw2 = 2* f_func(deltab)\nprint(f_func(umin**2)/f_func(bw2))\n\n1.999999999999998\n\n\n\nrho=0.1\nt_fwhm_gondolo_finite(1, 0.2, rho)\n\n/var/folders/qd/09mj47cx551c65glw6y47d6r0000gn/T/ipykernel_62183/2340527698.py:22: RuntimeWarning: invalid value encountered in sqrt\n  return quad(lambda x: np.sqrt(1 - m**2*np.sin(x)**2), 0, phi)[0]\n/var/folders/qd/09mj47cx551c65glw6y47d6r0000gn/T/ipykernel_62183/2340527698.py:22: IntegrationWarning: The occurrence of roundoff error is detected, which prevents \n  the requested tolerance from being achieved.  The error may be \n  underestimated.\n  return quad(lambda x: np.sqrt(1 - m**2*np.sin(x)**2), 0, phi)[0]\n/var/folders/qd/09mj47cx551c65glw6y47d6r0000gn/T/ipykernel_62183/2340527698.py:22: IntegrationWarning: Extremely bad integrand behavior occurs at some points of the\n  integration interval.\n  return quad(lambda x: np.sqrt(1 - m**2*np.sin(x)**2), 0, phi)[0]\n\n\n1.9595917942265424\n\n\n\numin = 0.2\nt_e = 10\nt_arr = np.linspace(-20,20,1000)\nu_arr = u_func(umin, t_arr, t_e)\nrho = 0.7\nA_fs_arr = np.array([A_gould(u, rho) for u in u_arr])\nA_ps_arr = np.array([A_ps(u) for u in u_arr])\nA_fs_int_arr = np.array([fast_magnification_finite_new(u, rho) for u in u_arr])\n\n\n#This is ~ 2*t_E for ut=1 and umin&lt;&lt;1\nt_duration(umin, 1, t_e, 0)/t_e\n\n0.003712691344232568\n\n\n\n#Novati relating fwhm to t_e for umin &lt;&lt; 1\nprint(np.sqrt(12)*umin*t_e)\n#Explicit calculation of fwhm\nprint(t_fwhm_point(umin, t_e))\n\n6.928203230275509\n7.75387693846924\n\n\n\n#Finite source calculation, small source\nprint(t_fwhm_finite(umin, t_e, 0.01))\n#Finite source calculation, larger source\nprint(t_fwhm_finite(umin, t_e, 0.5))\n\n7.75387693846924\n13.056528264132062\n\n\n\nplt.plot(u_arr, A_ps_arr, label=r\"Point Source\", ls='--', color='b')\nplt.plot(u_arr, A_fs_int_arr, label=r\"$\\rho = $\" + ' ' + str(rho) + ' ' + 'integrated', color='g')\n\nplt.axvline(fast_u_fwhm_func(rho, umin), color='g', linestyle='--')\n\n\nplt.ylim(1,6)\n# plt.ylim(5,50)\n\n# plt.xlim(-20,20)\n# plt.xlim(-2,2)\n\n\nplt.xlabel(\"u\")\nplt.ylabel(\"Magnification\")\nplt.legend()\n# plt.savefig(\"figures/ps_fs_magnification.pdf\")\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.plot(t_arr, A_ps_arr, label=r\"Point Source\", ls='--')\nplt.plot(t_arr, A_fs_arr, label=r\"$\\rho = $\" + ' ' + str(rho))\nplt.plot(t_arr, A_fs_int_arr, label=r\"$\\rho = $\" + ' ' + str(rho) + ' ' + 'integrated')\n\nplt.ylim(1,6)\n# plt.ylim(5,50)\n\nplt.xlim(-20,20)\n# plt.xlim(-2,2)\n\n\nplt.xlabel(\"Time\")\nplt.ylabel(\"Magnification\")\nplt.legend()\n# plt.savefig(\"figures/ps_fs_magnification.pdf\")\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.style.use(\"../examples/style.mplstyle\")\n# plt.style.use(\"../examples/style_new.mplstyle\")\nsns.set_palette(\"colorblind\")\n\n\numin = 0.2\nt_e = 10\nt_arr = np.linspace(-24,24,1000)\nu_arr = u_func(umin, t_arr, t_e)\nrho = 0.7\nA_fs_arr = np.array([A_gould(u, rho) for u in u_arr])\nA_ps_arr = np.array([A_ps(u) for u in u_arr])\n\n\nplt.plot(t_arr, A_fs_arr, label=r\"$\\rho = $\" + ' ' + str(rho), linewidth=3)\nplt.plot(t_arr, A_ps_arr, label=r\"Point Source\", ls='--', linewidth=3)\n\nplt.ylim(1,6)\n\nplt.xlim(-20,20)\n# plt.xlim(-2,2)\n\nplt.xlabel(\"Time\")\nplt.ylabel(\"Magnification\")\nplt.legend()\n# plt.savefig(\"figures/ps_fs_magnification.pdf\")\n# plt.savefig(\"../examples/figures/ps_fs_magnification.pdf\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n# plt.plot(t_arr, A_fs_arr, label=r\"$\\rho = $\" + ' ' + str(rho), linewidth=3)\nplt.plot(t_arr, A_ps_arr, label=r\"Point Source\", linewidth=3)\n\nplt.axhline(1.34, color='k', linestyle='--', label=r'$A_T$',linewidth=3)\nplt.axvline(-10, color='k', linestyle=':', label=r'$u_T$',linewidth=3)\nplt.axvline(10, color='k', linestyle=':', label=r'$u_T$',linewidth=3)\n\n\nplt.text(-20, 1.6, r'$A_T$', fontsize=30)\n\n# plt.text(1.2, 2.5, r'$u_T$', fontsize=30)\n\n\nplt.ylim(1,6)\n\nplt.xlim(-24,24)\n# plt.xlim(-2,2)\n\nplt.xlabel(\"Time\")\nplt.ylabel(\"Magnification\")\n# plt.legend()\n# plt.savefig(\"figures/ps_fs_magnification.pdf\")\n# plt.savefig(\"../examples/figures/ps_fs_magnification.pdf\")\n# plt.savefig(\"../examples/figures/t_dur_lightcurve.pdf\")\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\nu_arr_2 = np.linspace(-3,3,200)\nrho = 0.6\nA_fs_arr_2 = np.array([A_gould(abs(u), rho) for u in u_arr_2])\nA_fs_int_arr2 = np.array([fast_magnification_finite_new(u, rho) for u in abs(u_arr_2)])\n\n# plt.plot(u_arr_2, A_fs_arr_2, linewidth=3,color='C0')\nplt.plot(u_arr_2, A_fs_int_arr2, linewidth=3,color='C0')\n\nplt.axhline(1.34, color='k', linestyle='--', label=r'$A_T$',linewidth=3)\nplt.axvline(1.1, color='k', linestyle=':', label=r'$u_T$',linewidth=3)\n\nplt.axhline((1 + 4/rho**2)**(1/2), color='k', linestyle='--', label=r'$A_\\rm{max}$',linewidth=3 )\n\n\n\nplt.text(1.2, 2.5, r'$u_T$', fontsize=30)\nplt.text(-2.5, 1.5, r'$A_T$', fontsize=30)\nplt.text(-2.5, 3.2, r'$A_{\\rm{max}}$', fontsize=30)\n\n\n\nplt.ylim(1,4)\n\nplt.xlim(-3,3)\n# plt.xlim(-2,2)\n\nplt.xlabel(\"u\")\nplt.ylabel(\"A\")\n# plt.legend(fontsize=16)\n# plt.savefig(\"figures/ps_fs_magnification.pdf\")\n# plt.savefig(\"../examples/figures/ps_fs_magnification.pdf\")\n# plt.savefig(\"../examples/figures/A_vs_u_lightcurve.pdf\")\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n(1 + 4/0.6**2)**(1/2)\n\n3.48010216963685\n\n\n\nimport os\nprint(os.environ['PATH'])\n\n/opt/hostedtoolcache/Python/3.9.18/x64/bin:/opt/hostedtoolcache/Python/3.9.18/x64:/snap/bin:/home/runner/.local/bin:/opt/pipx_bin:/home/runner/.cargo/bin:/home/runner/.config/composer/vendor/bin:/usr/local/.ghcup/bin:/home/runner/.dotnet/tools:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin\n\n\n\nos.environ['PATH'] += os.pathsep + '/Library/TeX/texbin'",
    "crumbs": [
      "lightcurves"
    ]
  },
  {
    "objectID": "mw.html",
    "href": "mw.html",
    "title": "core",
    "section": "",
    "text": "source\n\nfoo\n\n foo ()",
    "crumbs": [
      "core"
    ]
  },
  {
    "objectID": "pbh.html",
    "href": "pbh.html",
    "title": "pbh",
    "section": "",
    "text": "plt.style.use(\"../examples/style.mplstyle\")\nsns.set_palette(\"colorblind\")\n\n\nsource\n\nPbh\n\n Pbh (mass:float, f_dm:float, mw_model=None, m31_model=None, l=None,\n      b=None, u_t=1, ds=770, lognorm=False, sigma=None, ut_interp=None)\n\nA class to represent a PBH population\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmass\nfloat\n\nPBH mass in solar masses\n\n\nf_dm\nfloat\n\nPBH fraction of the DM density\n\n\nmw_model\nNoneType\nNone\n\n\n\nm31_model\nNoneType\nNone\n\n\n\nl\nNoneType\nNone\n\n\n\nb\nNoneType\nNone\n\n\n\nu_t\nint\n1\n\n\n\nds\nint\n770\n\n\n\nlognorm\nbool\nFalse\n\n\n\nsigma\nNoneType\nNone\n\n\n\nut_interp\nNoneType\nNone\n\n\n\n\n\nm_lens = 3e-5\npbh = Pbh(m_lens, 1, l=l, b=b, ds=ds, lognorm=True, sigma=0.1)\n# pbh = Pbh(m_lens, 1, l=1.0, b=-1.03, ds=8.5, lognorm=True, sigma=0.1, u_t=1)\n\nts = np.logspace(-2,1,50)\n\n\npbh.rate_mw_new(epsabs=0, epsrel=1e-1, tcad=0.07, tobs=100, finite=True)\n\n2.7384615867469513e-08\n\n\n\ndef opt_depth_integrand(d):\n    return (pbh.mw_model.density_dm(d, l, b) + pbh.m31_model.density_dm(d, l, b))/pbh.mass * np.pi * einstein_rad(d, pbh.mass, pbh.ds)**2\nd_arr = np.logspace(-3, np.log10(pbh.ds*0.99), 1000)\nopt_depth_arr = np.array([quad(opt_depth_integrand, 0, d)[0] for d in d_arr])\n\n\nplt.loglog(d_arr, opt_depth_arr, color='darkgreen')\nplt.ylim(1e-8, 1e-5)\nplt.xlim(3, 1e3)\nplt.show()\n\n\n\n\n\n\n\n\n\npbh_wide = Pbh(m_lens, 1, l=1.0, b=-1.03, ds=8.5, lognorm=True, sigma=1.)\npbh_med = Pbh(m_lens, 1, l=1.0, b=-1.03, ds=8.5, lognorm=True, sigma=0.5)\n\n\nm_arr = np.logspace(-12, -1, 10000)\nmass_func_arr = np.array([pbh.mass_function(m) for m in m_arr])\nmass_func_arr_wide = np.array([pbh_wide.mass_function(m) for m in m_arr])\nmass_func_arr_med = np.array([pbh_med.mass_function(m) for m in m_arr])\n\n\nplt.loglog(m_arr, mass_func_arr, label=\"sigma=0.01\")\nplt.loglog(m_arr, mass_func_arr_med, label=\"sigma=0.5\")\nplt.loglog(m_arr, mass_func_arr_wide, label=\"sigma=1.\")\nplt.ylim(1e0, 1e6)\nplt.xlim(1e-6, 1e-3)\nplt.xlabel(r\"$M_{\\rm{PBH} [M_{\\odot}]}$\")\nplt.ylabel(r'$f(M)$')\nplt.legend()\n# plt.savefig(\"../examples/figures/log_norm_mass_func.pdf\")\n\n\n\n\n\n\n\n\n\n#test object creation\ntest_eq(pbh.mass, m_lens)\n\n#test differential rate\ntest_eq(pbh.differential_rate_total(1), pbh.differential_rate_mw(1) + pbh.differential_rate_m31(1))\n\n#test that threshold parameter is close to 1 for small d\ntest_close(pbh.umin_upper_bound(0), 1, eps=1e-2)\n\n#test that threshold parameter is close to 0 when close to source\ntest_close(pbh.umin_upper_bound(ds*0.99999), 0, eps=1e-2)\n\n#test that umin lower bound is correctly inherited from Lens\ntest_eq(pbh.umin_lower_bound(0), 0)\n\n\nd_arr = np.logspace(0, np.log10(ds*0.999), 1000)\n\nm_pbh_arr = np.logspace(-10, -6, 5)\n\nrhos_calc = [[rho_func(m, d, ds) for d in d_arr] for m in m_pbh_arr]\n\nfor m, rhos in zip(m_pbh_arr, rhos_calc):\n    plt.plot(d_arr, ut_func_new(rhos, 1.34), label=f\"$m= {m:.2e}$\")\n\nplt.xscale(\"log\")\nplt.yscale(\"log\")\nplt.xlim(min(d_arr), max(d_arr))\nplt.ylim(5e-1, 2)\n\nplt.xlabel(\"d [kpc]\")\nplt.ylabel(\"$u_{T}$\")\nplt.title(\"Finite size M31 Center Source\")\n\nplt.legend()\nplt.show()",
    "crumbs": [
      "pbh"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "LensCalcPy",
    "section": "Install",
    "text": "Install\npip install LensCalcPy",
    "crumbs": [
      "LensCalcPy"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "LensCalcPy",
    "section": "How to use",
    "text": "How to use\nThis package is primarily used to calculate the expected rate of microlensing events for a given population of lenses. At its core, the package is designed to compute integrals of the form:\n\\(\\frac{d\\Gamma}{dM\\,dd_L\\,d\\hat{t}\\,du_\\text{min}} =\n     \\frac{2}{\\sqrt{u_T^2 - u_{\\rm{min}}^2}} \\frac{v_T^4}{v_c^2} \\exp \\Big[ -\\frac{v_T^2}{v_c^2}\\Big] n(d_L) f(M) \\varepsilon(\\hat{t}),\\)\nwhich is the differential rate for a given line of sight over \\(d_L\\), mass function \\(f(M)\\), event duration \\(\\hat{t}\\), and minimum impact parameter \\(u_\\text{min}\\). In practice, the user can define the parameters of their survey (Line of sight, cadence, observation duration) and compute observables such as the distribution of crossing times \\(t_E\\), total expected events, etc.\nThe full documentation can be found here. The source code, located in nbs, is intended to be easily interacrtable and modularizable, so adding functionality is straightforward. For real-world examples, see the notebooks in the examples folder. Below are some minimal examples for PBH (Primordial Black Hole) lenses and UBO (Unbound Objects) lenses. Here, the line of sight is towards M31, the Andromeda galaxy.\nWe can calculate the distribution of crossing times for a given PBH population\n\nf_pbh = 1 # fraction of dark matter in PBHs\n\nts = np.logspace(-2, 1, 20)\npbhs = [Pbh(10**(i), f_pbh, l=l, b=b) for i in np.linspace(-9, -7, 3)]\nresult = np.zeros((len(pbhs), len(ts)))\nfor i, pbh in enumerate(pbhs):\n    result[i, :] = pbh.compute_differential_rate(ts)\n\n\nfor i, pbh in enumerate(pbhs):\n    plt.loglog(ts, result[i], label=r\"$M_{\\rm{PBH}} = $\" + scientific_format(pbh.mass,0) + \"$M_{\\odot}$\")\n\nplt.xlabel(r\"$t_E$ [h]\", fontsize=16)\nplt.ylabel(r\"$d\\Gamma/dt$ [events/star/hr/hr]\", fontsize=16)\nplt.xlim(1e-2, 1e1)\nplt.ylim(1e-10, 1e-4)\n\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nSimilarly, we can calculate the distribution of crossing times for an FFP population with mass function \\(\\frac{dM}{d \\log(M)} \\propto M^{-p}\\)\n\np = 1\nfp = Ffp(p, l=l, b=b)\n\n\ndef differential_rate_mw_mass(m, tcad = 0.07, tobs= 3, finite=True):\n    return fp.differential_rate_mw_mass(m, tcad=tcad, tobs=tobs, finite=finite)\n\nm_arr = np.logspace(-15, -3, 20)\nwith Pool() as pool:\n    func = functools.partial(differential_rate_mw_mass, tcad=0.07, tobs=3, finite=True)\n    diff_rates  = np.array(list(tqdm(pool.imap(func, m_arr), total=len(m_arr))))\n\n100%|██████████| 20/20 [00:08&lt;00:00,  2.29it/s]\n\n\n\nplt.loglog(m_arr/3e-6, diff_rates, label=r'Finite Source, $t_{\\rm{cad}} = 4.2 ~\\rm{min}$', color='k')\n\nplt.ylim(1e-24, 1e-9)\nplt.xlim(np.min(m_arr)/3e-6, 1e1)\n\nplt.xlabel(\"Mass [$M_{\\oplus}$]\")\nplt.ylabel(r\"$d\\Gamma/dM$ [events/star/hr/mass]\")\nplt.title('MW lens, M31 source')\nplt.legend()\nplt.show()",
    "crumbs": [
      "LensCalcPy"
    ]
  },
  {
    "objectID": "stats.html",
    "href": "stats.html",
    "title": "Stats",
    "section": "",
    "text": "source\n\n\n\n generate_observed_counts_with_bump (bin_centers, a, index, bump_position,\n                                     bump_height)\n\n\nsource\n\n\n\n\n likelihood (observed_counts, expected_counts)\n\n\nsource\n\n\n\n\n power_law (x, a=1, index=-2)",
    "crumbs": [
      "Stats"
    ]
  },
  {
    "objectID": "stats.html#toy-model-for-mass-likelihood",
    "href": "stats.html#toy-model-for-mass-likelihood",
    "title": "Stats",
    "section": "",
    "text": "source\n\n\n\n generate_observed_counts_with_bump (bin_centers, a, index, bump_position,\n                                     bump_height)\n\n\nsource\n\n\n\n\n likelihood (observed_counts, expected_counts)\n\n\nsource\n\n\n\n\n power_law (x, a=1, index=-2)",
    "crumbs": [
      "Stats"
    ]
  },
  {
    "objectID": "stats.html#mle-and-log-likelihood-ratio-test",
    "href": "stats.html#mle-and-log-likelihood-ratio-test",
    "title": "Stats",
    "section": "MLE and Log Likelihood Ratio Test",
    "text": "MLE and Log Likelihood Ratio Test\n\nsource\n\nget_MLE_params\n\n get_MLE_params (bin_centers, observed_counts)\n\n\nsource\n\n\nneg_log_likelihood\n\n neg_log_likelihood (params, bin_centers, observed_counts)\n\n\n# Generate example observed counts with a bump\na = 200\nindex = -2\nbump_position = 6\nbump_height = 20\n\nmin_bin = 1\nmax_bin = 10\nbin_edges = np.linspace(min_bin,max_bin,10)  # Assuming bins from -6 to -2\nbin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2\n\nobserved_counts = generate_observed_counts_with_bump(bin_centers, a, index, bump_position, bump_height)\n\noptimized_params_bump = get_MLE_params(bin_centers, observed_counts)\nexpected_counts_opt = generate_observed_counts_with_bump(bin_centers, *optimized_params_bump)\n\nprint(\"Optimized parameters: a = {:.2f}, index = {:.2f}, bump_position = {:.2f}, bump_height = {:.2f}\".format(*optimized_params_bump))\nprint(\"True parameters: a = {:.2f}, index = {:.2f}, bump_position = {:.2e}, bump_height = {:.2f}\".format(a, index, bump_position, bump_height))\n\nOptimized parameters: a = 199.45, index = -2.06, bump_position = 5.63, bump_height = 17.01\nTrue parameters: a = 200.00, index = -2.00, bump_position = 6.00e+00, bump_height = 20.00\n\n\n\nsource\n\n\nllr_test\n\n llr_test (bin_centers, observed_counts)\n\n\n# Calculate the likelihood ratio test statistic\nlr_statistic = llr_test(bin_centers, observed_counts)\n\n# Calculate the p-value using a chi-square distribution\np_value = chi2.sf(lr_statistic, df=2)  # Two degrees of freedom for the difference in number of parameters\n\n# Print the results\nprint(\"Likelihood ratio test statistic:\", lr_statistic)\nprint(\"p-value:\", p_value)\nif p_value &lt; 0.05:\n    print(\"The null hypothesis is rejected at the 95% significance level.\")\nelse:\n    print(\"The null hypothesis is not rejected at the 95% significance level.\")\n\nLikelihood ratio test statistic: 26.61829810637751\np-value: 1.659243050630246e-06\nThe null hypothesis is rejected at the 95% significance level.\n\n\n\n# Plot the observed counts and the initial/optimized expected counts\nplt.figure(figsize=(12, 4))\nplt.subplot(121)\nplt.bar(bin_centers, observed_counts, alpha=0.7, label=\"Observed\")\nplt.plot(bin_centers, power_law(bin_centers, a=a, index=index), label=\"Initial Expected\", color='r', linewidth=2)\nplt.xlabel(\"Bin center\")\nplt.ylabel(\"Counts\")\nplt.legend()\nplt.title(\"Observed Counts vs Initial Expected Counts\")\n\nplt.subplot(122)\nplt.bar(bin_centers, observed_counts, alpha=0.7, label=\"Observed\")\nplt.plot(bin_centers, expected_counts_opt, label=\"Optimized Expected\", color='g', linewidth=2)\nplt.xlabel(\"Bin center\")\nplt.ylabel(\"Counts\")\nplt.legend()\nplt.title(\"Observed Counts vs Optimized Expected Counts\")\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "Stats"
    ]
  },
  {
    "objectID": "stats.html#get-data-from-survey-to-analyze",
    "href": "stats.html#get-data-from-survey-to-analyze",
    "title": "Stats",
    "section": "Get data from survey to analyze",
    "text": "Get data from survey to analyze",
    "crumbs": [
      "Stats"
    ]
  },
  {
    "objectID": "utils.html",
    "href": "utils.html",
    "title": "utils",
    "section": "",
    "text": "source\n\nscientific_format\n\n scientific_format (x, pos)\n\nFormats a number in scientific notation in latex\n\nsource\n\n\nget_primed_coords\n\n get_primed_coords (d:float, l:float=121.2, b:float=-21.6)\n\nGet galactocentric coordinates x’, y’ given galactic latitude and longitude l, b, and distance d\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nd\nfloat\n\ndistance from Sun in km\n\n\nl\nfloat\n121.2\ngalactic longitude in degrees\n\n\nb\nfloat\n-21.6\ngalactic latitude in degrees\n\n\nReturns\ntuple\n\n\n\n\n\n\nsource\n\n\nevent_duration\n\n event_duration (d:float, mass:float, umin:float, v_rel:float, ut:float,\n                 ds:float)\n\n\n\n\n\nType\nDetails\n\n\n\n\nd\nfloat\ndistance from the Sun in kpc\n\n\nmass\nfloat\nmass of the lens in Msun\n\n\numin\nfloat\nminimum impact parameter\n\n\nv_rel\nfloat\ntransverse velocity in km/s\n\n\nut\nfloat\nthreshold impact parameter\n\n\nds\nfloat\ndistance to the source in kpc\n\n\nReturns\nfloat\nevent duration in seconds\n\n\n\n\nsource\n\n\nvelocity_radial\n\n velocity_radial (d:float, mass:float, umin:float, t:float, ut:float,\n                  ds:float)\n\n\n\n\n\nType\nDetails\n\n\n\n\nd\nfloat\ndistance from the Sun in kpc\n\n\nmass\nfloat\nmass of the lens in Msun\n\n\numin\nfloat\nminimum impact parameter\n\n\nt\nfloat\ncrossing time in hours\n\n\nut\nfloat\nthreshold impact parameter\n\n\nds\nfloat\ndistance to the source in kpc\n\n\nReturns\nfloat\nradial velocity in km/s\n\n\n\n\nsource\n\n\neinstein_rad\n\n einstein_rad (d:float, mass:float, ds:float)\n\n\n\n\n\nType\nDetails\n\n\n\n\nd\nfloat\ndistance from the Sun in kpc\n\n\nmass\nfloat\nmass of the lens in Msun\n\n\nds\nfloat\ndistance to the source in kpc\n\n\nReturns\nfloat\nEinstein radius in kpc\n\n\n\n\nsource\n\n\ndist\n\n dist (d:float, ds:float=770)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nd\nfloat\n\ndistance from the Sun in kpc\n\n\nds\nfloat\n770\ndistance to the source in kpc\n\n\nReturns\nfloat\n\nweighted lensing distance in kpc\n\n\n\n\nsource\n\n\nvelocity_dispersion_m31\n\n velocity_dispersion_m31 (r:float)\n\n\n\n\n\nType\nDetails\n\n\n\n\nr\nfloat\ndistance from the M31 center in kpc\n\n\nReturns\nfloat\nvelocity dispersion in km/s\n\n\n\n\nsource\n\n\nvelocity_dispersion_mw\n\n velocity_dispersion_mw (r:float)\n\n\n\n\n\nType\nDetails\n\n\n\n\nr\nfloat\ndistance from the MW center in kpc\n\n\nReturns\nfloat\nvelocity dispersion in km/s\n\n\n\n\nsource\n\n\nmass_enclosed_m31\n\n mass_enclosed_m31 (r:float)\n\n\n\n\n\nType\nDetails\n\n\n\n\nr\nfloat\ndistance to M31 center in kpc\n\n\nReturns\nfloat\nenclosed DM mass in Msun\n\n\n\n\nsource\n\n\nmass_enclosed_mw\n\n mass_enclosed_mw (r:float)\n\n\n\n\n\nType\nDetails\n\n\n\n\nr\nfloat\ndistance to MW center in kpc\n\n\nReturns\nfloat\nenclosed DM mass in Msun\n\n\n\n\nsource\n\n\ndensity_m31\n\n density_m31 (r:float)\n\n\n\n\n\nType\nDetails\n\n\n\n\nr\nfloat\ndistance to M31 center in kpc\n\n\nReturns\nfloat\nDM density in Msun/kpc^3\n\n\n\n\nsource\n\n\ndensity_mw\n\n density_mw (r:float)\n\n\n\n\n\nType\nDetails\n\n\n\n\nr\nfloat\ndistance to MW center in kpc\n\n\nReturns\nfloat\nDM density in Msun/kpc^3\n\n\n\n\nsource\n\n\ndist_m31\n\n dist_m31 (d:float)\n\n\n\n\n\nType\nDetails\n\n\n\n\nd\nfloat\ndistance from the Sun in kpc\n\n\nReturns\nfloat\ndistance to the M31 center in kpc\n\n\n\n\nsource\n\n\ndist_mw\n\n dist_mw (d:float)\n\n\n\n\n\nType\nDetails\n\n\n\n\nd\nfloat\ndistance from the Sun in kpc\n\n\nReturns\nfloat\ndistance to the MW center in kpc\n\n\n\n\n#sanity checks\ntest_eq(mass_enclosed_m31(0), 0)\ntest_eq(mass_enclosed_mw(0), 0)\ntest_eq(velocity_dispersion_m31(0), 0)\ntest_eq(velocity_dispersion_mw(0), 0)\n\n\n#test that galactic center is at (0, 0, 0) for l=b=0\ntest_eq(get_primed_coords(rEarth, 0, 0), (0, 0, 0))\n\n#test that earth's distance from galactic center is rEarth, even in primed coordinates\ntest_close(np.sum(np.array(get_primed_coords(0))**2)**(1/2), rEarth)\n\n#test eq.4 of appendix in https://arxiv.org/pdf/1701.02151.pdf\ntest_close(einstein_rad(100, 1e-8, dsM31)*(3600 * 180 / np.pi)/100, 3e-8, eps=1e-8)\n\n\nsource\n\n\nmake_ut_interp\n\n make_ut_interp (n_points=40, ds=770, A_thresh=1.34)\n\n\nsource\n\n\nu_t_finite_wave\n\n u_t_finite_wave (m_pbh, lam, dl, ds, A_thresh=1.34)\n\n\nsource\n\n\nu_t_point\n\n u_t_point (A_thresh=1.34)\n\n\nsource\n\n\nu_t_finite\n\n u_t_finite (m_pbh, dl, ds, A_thresh=1.34)\n\n\nsource\n\n\nmagnification_finite\n\n magnification_finite (m_pbh, u, dl, ds)\n\n\nsource\n\n\nmagnification_finite_wave\n\n magnification_finite_wave (m_pbh, lam, u, dl, ds)\n\n\nsource\n\n\nintegrand_polar\n\n integrand_polar (r, theta, u)\n\n\nsource\n\n\nintegrand_polar_wave\n\n integrand_polar_wave (r, theta, w, u)\n\n\nsource\n\n\ndisplacement\n\n displacement (x, y, u)\n\n\nsource\n\n\nmagnification_wave\n\n magnification_wave (w, u)\n\n\nsource\n\n\nmagnification\n\n magnification (u)\n\nCompute the magnification given the impact parameter ‘u’ in the point-source-point-lens limit.\n\nsource\n\n\nrho_func\n\n rho_func (m_pbh, dl, ds)\n\n\nsource\n\n\nw_func\n\n w_func (m_pbh, lam)\n\n\nsource\n\n\nu_t_dressed_101\n\n u_t_dressed_101 (rho, r90)\n\n\nsource\n\n\nu_t_dressed\n\n u_t_dressed (rho, r90)\n\n\nsource\n\n\nu_t_axion_101\n\n u_t_axion_101 (rho, r90)\n\n\nsource\n\n\nu_t_axion\n\n u_t_axion (rho, r90)\n\n\nsource\n\n\nu_t_nfw_101\n\n u_t_nfw_101 (rho, r90)\n\n\nsource\n\n\nu_t_nfw\n\n u_t_nfw (rho, r90)\n\n\nsource\n\n\nu_t_dressed_thresh\n\n u_t_dressed_thresh (rho, r90)\n\n\nsource\n\n\nu_t_axion_thresh\n\n u_t_axion_thresh (rho, r90)\n\n\nsource\n\n\nu_t_nfw_thresh\n\n u_t_nfw_thresh (rho, r90)\n\n\nu_t_nfw(1,1)\n\narray(3.87074043)\n\n\n\nmagnification(0.5)\n\n2.182820625326997\n\n\n\nm = 1e-7 #mars mass\nd_arr = np.linspace(0, 769.9, 1000)\nrho_arr = np.array([rho_func(m, d, ds) for d in d_arr])\n\n\nplt.plot(d_arr, rho_arr, label=r\"$\\rho = \\Theta_s/\\Theta_E$\")\nplt.xlabel(\"dl (kpc)\")\n# plt.ylabel(r\"$\\rho = \\Theta_s/\\Theta_E$\")\n# plt.plot(d_arr, ut_interp(d_arr, m), label=\"u_t\")\nplt.axvline(d_arr[np.where(rho_arr &gt;= 2)[0][0]], ls=\"--\", color=\"k\")\n\nplt.xscale(\"log\")\nplt.xlim(720, 769)\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.plot(d_arr, 1 + 2/(rho_arr)**2)\nplt.yscale(\"log\")\nplt.xscale(\"log\")\nplt.xlabel(\"dl (kpc)\")\nplt.ylabel(\"Peak Finite Magnification\")\nplt.show()\n\n\n\n\n\n\n\n\n\ndef magnification_finite_new(u, rho):\n    integrand = lambda r, theta: integrand_polar(r, theta, u)\n    result, _ = nquad(integrand, [[0, rho], [0, 2 * pi]])\n    return result / (pi * rho**2)\n\ndef u_t_finite_new(rho, A_thresh=1.34):\n    func = lambda u: magnification_finite_new(u,rho) - A_thresh\n    u_min = 0\n    u_max = 15\n\n    try:\n        return brentq(func, u_min, u_max)\n    except ValueError:\n        return 0\n\n\ndef compute_u_t(args):\n    rho, A_thresh = args\n    return u_t_finite_new(rho, A_thresh)\n\nargs_list = [(rho, A_thresh) for rho in rhos for A_thresh in A_threshs]\n\nwith Pool() as p:\n    u_ts_flat = p.map(compute_u_t, args_list)\nu_ts_new = np.array(u_ts_flat).reshape(len(rhos), len(A_threshs))\n\nut_interp_rho = interp2d(rhos, A_threshs, u_ts_new.T)\n\nwith open('../LensCalcPy/interpolations/ut_interp_rho.pkl', 'wb') as f:\n    pickle.dump(ut_interp_rho, f)\n\n/var/folders/qd/09mj47cx551c65glw6y47d6r0000gn/T/ipykernel_70250/3744683341.py:11: DeprecationWarning: `interp2d` is deprecated!\n`interp2d` is deprecated in SciPy 1.10 and will be removed in SciPy 1.13.0.\n\nFor legacy code, nearly bug-for-bug compatible replacements are\n`RectBivariateSpline` on regular grids, and `bisplrep`/`bisplev` for\nscattered 2D data.\n\nIn new code, for regular grids use `RegularGridInterpolator` instead.\nFor scattered data, prefer `LinearNDInterpolator` or\n`CloughTocher2DInterpolator`.\n\nFor more details see\n`https://scipy.github.io/devdocs/notebooks/interp_transition_guide.html`\n\n  ut_interp_rho = interp2d(rhos, A_threshs, u_ts_new.T)\n\n\n\nsource\n\n\nut_func_new\n\n ut_func_new (rho, A_thresh)\n\n\nplt.plot(rhos, ut_interp_rho(rhos, 1.34))\nplt.plot(rhos, ut_interp_rho(rhos, 1.01))\n\nplt.xlabel(r'$\\rho$')\nplt.ylabel(r'$u_t$')\nplt.show()\n\n/var/folders/qd/09mj47cx551c65glw6y47d6r0000gn/T/ipykernel_70250/2914777924.py:1: DeprecationWarning:         `interp2d` is deprecated!\n        `interp2d` is deprecated in SciPy 1.10 and will be removed in SciPy 1.13.0.\n\n        For legacy code, nearly bug-for-bug compatible replacements are\n        `RectBivariateSpline` on regular grids, and `bisplrep`/`bisplev` for\n        scattered 2D data.\n\n        In new code, for regular grids use `RegularGridInterpolator` instead.\n        For scattered data, prefer `LinearNDInterpolator` or\n        `CloughTocher2DInterpolator`.\n\n        For more details see\n        `https://scipy.github.io/devdocs/notebooks/interp_transition_guide.html`\n\n  plt.plot(rhos, ut_interp_rho(rhos, 1.34))\n/var/folders/qd/09mj47cx551c65glw6y47d6r0000gn/T/ipykernel_70250/2914777924.py:2: DeprecationWarning:         `interp2d` is deprecated!\n        `interp2d` is deprecated in SciPy 1.10 and will be removed in SciPy 1.13.0.\n\n        For legacy code, nearly bug-for-bug compatible replacements are\n        `RectBivariateSpline` on regular grids, and `bisplrep`/`bisplev` for\n        scattered 2D data.\n\n        In new code, for regular grids use `RegularGridInterpolator` instead.\n        For scattered data, prefer `LinearNDInterpolator` or\n        `CloughTocher2DInterpolator`.\n\n        For more details see\n        `https://scipy.github.io/devdocs/notebooks/interp_transition_guide.html`\n\n  plt.plot(rhos, ut_interp_rho(rhos, 1.01))\n\n\n\n\n\n\n\n\n\n\n\nTesting finite size effects\n\nm_pbh_arr = np.logspace(-9, -6, 4)\nd_arr = np.linspace(0, 8.5, 1000)\nrhos_calc = [[rho_func(m, d, 8.51) for d in d_arr] for m in m_pbh_arr]\n\nfor m, rhos in zip(m_pbh_arr, rhos_calc):\n    plt.plot(d_arr, ut_func_new(rhos,1.34), label=f\"$m= {m:.2e}$\")\n\nplt.xscale(\"log\")\nplt.yscale(\"log\")\nplt.xlim(1e0, 9)\nplt.ylim(5e-1, 2)\n\nplt.xlabel(\"d [kpc]\")\nplt.ylabel(\"$u_{T}$\")\nplt.title(\"Finite size MW Center Source\")\n\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n#Test eq. 7 of https://arxiv.org/pdf/1905.06066.pdf\ntest_eq(magnification_wave(2, 0), np.pi*2/(1 - np.exp(-np.pi*2)))\n\n#Test that for small wavelength, there is essentially no magnification\ntest_close(magnification_wave(1e-5, 1),1, eps=1e-3)\n\n#Test that for large impact parameter, there is essentially no magnification\ntest_close(magnification_wave(10, 10),1, eps=1e-3)\n\n\nu = 1\nm_pbh = 1e-11\nlam = 6000\ndl = 1\nds = 770\nA_thresh = 1.34\n\nprint(magnification_finite_wave(m_pbh, lam, u, dl, ds))\nprint(u_t_finite_wave(m_pbh, lam, dl, ds))\nprint(u_t_finite(m_pbh, dl, ds))\n\n1.4081218406030171\n1.0919519513342404\n1.0932816931111\n\n\n\nus = np.linspace(0,5,20)\nmags_point = [magnification(u) for u in us]\nmags_finite = [magnification_finite(m_pbh, u, 6, ds) for u in us]\nmags_finite_wave = [magnification_finite_wave(m_pbh, lam, u, 1, ds) for u in us]\nut_finite = u_t_finite(m_pbh, 6, ds)\nut_finite_wave = u_t_finite_wave(m_pbh, lam, 1, ds)\n\n\nplt.plot(us, mags_point, color='orange', label='Point')\nplt.plot(us, mags_finite, color='blue', label='Finite')\nplt.plot(us, mags_finite_wave, color='red', label='Finite + Wave')\nplt.axhline(y=A_thresh, color='gray', linestyle='-.')\nplt.axvline(x=ut_finite, color='blue', linestyle='--')\nplt.axvline(x=ut_finite_wave, color='red', linestyle='--')\nplt.axvline(x=1, color='orange', linestyle='--')\nplt.xlim(0,5)\nplt.ylim(0.6,2.0)\nplt.show()\n\n\n\n\n\n\n\n\n\nus = np.logspace(-3,1,20)\nfor m in np.logspace(-11, -9, 3):\n    mags =[magnification_wave(w_func(m, lam), u) for u in us]\n    plt.plot(us, mags, label=f'm={m:.2e}')\nplt.xscale('log')\nplt.yscale('log')\nplt.xlabel('u')\nplt.ylabel('magnification')\nplt.xlim(1e-3, 1e1)\nplt.ylim(2e-3, 3e3)\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\nFWHM Conversions\n\ndef magnification_finite_new(u, rho):\n    integrand = lambda r, theta: integrand_polar(r, theta, u)\n    result, _ = nquad(integrand, [[0, rho], [0, 2 * np.pi]])\n    return result / (np.pi * rho**2)\n\n\n# u_vals = np.logspace(-2, 1, 29)\nu_vals = np.insert(np.logspace(-2, 1, 29), 0, 0)\nrho_vals = np.logspace(-2, 1, 30)\nz_vals = np.array([[magnification_finite_new(u, rho) for u in u_vals] for rho in tqdm(rho_vals)])\nmag_finite_interp = RegularGridInterpolator((rho_vals, u_vals), z_vals, method='linear', bounds_error=False, fill_value=None)\n\ndef fast_magnification_finite_new(u, rho):\n    return mag_finite_interp([float(rho), float(u)])\n    \ndef fast_u_fwhm_func(rho, umin):\n    Amax = fast_magnification_finite_new(umin, rho)\n    if Amax&lt;1:\n        return 0\n    func = lambda u: fast_magnification_finite_new(u, rho) - (1+(Amax-1)/2)\n    return fsolve(func, 1)\n\nz_u_vals = np.array([[fast_u_fwhm_func(rho, u) for u in u_vals] for rho in tqdm(rho_vals)])\nu_fwhm_interp = RegularGridInterpolator((rho_vals, u_vals), z_u_vals, method='linear', bounds_error=False, fill_value=None)\n\n100%|██████████| 30/30 [01:53&lt;00:00,  3.79s/it]\n  0%|          | 0/30 [00:00&lt;?, ?it/s]/Users/nolansmyth/opt/anaconda3/lib/python3.9/site-packages/scipy/optimize/_minpack_py.py:177: RuntimeWarning: The iteration is not making good progress, as measured by the \n  improvement from the last ten iterations.\n  warnings.warn(msg, RuntimeWarning)\n100%|██████████| 30/30 [00:00&lt;00:00, 40.36it/s]\n\n\n\n# with open('../LensCalcPy/interpolations/u_fwhm_interp.pkl', 'wb') as f:\n#     pickle.dump(u_fwhm_interp, f)\n\n\nu_fwhm_interp([15,1])\n\narray([[14.29405895]])\n\n\n\nsource\n\n\nt_e_from_fwhm\n\n t_e_from_fwhm (t_fwhm, umin, finite, rho=None)\n\n\nsource\n\n\nuhm_point\n\n uhm_point (umin)\n\n\nsource\n\n\nt_fwhm_gondolo\n\n t_fwhm_gondolo (t_e, umin)\n\n\nsource\n\n\nf_func\n\n f_func (x)\n\n\nrho=0.02\nu_hms = np.array([u_fwhm_interp([rho, umin])[0] for umin in u_vals])\n\n\nplt.loglog(u_vals, u_hms)\nplt.plot(u_vals, u_vals, ls='--', color='k')\nplt.axhline(y=rho, color='k', ls='--')\nplt.xlabel(r'$u_{min}$')\nplt.ylabel(r'$u_{hm}$')\n\nText(0, 0.5, '$u_{hm}$')\n\n\n\n\n\n\n\n\n\n\nu_min = 0.01\nrho=0.1\nt_fwhms = np.logspace(-1, 1, 30)\nt_es_point = np.array([t_e_from_fwhm(t_fwhms, u_min, finite=False) for t_fwhms in t_fwhms])\nt_es_finite = np.array([t_e_from_fwhm(t_fwhms, u_min, finite=True, rho=rho) for t_fwhms in t_fwhms])\n\n\n# plt.plot(t_fwhms, t_es_point, label='Point')\nplt.plot(t_fwhms, t_es_finite, label='Finite')\nplt.plot(t_fwhms, t_fwhms, label='t_fwhm', ls='--', color='k')\nplt.legend()\nplt.xlabel('t_fwhm')\nplt.ylabel('t_e')\nplt.title('u_min = ' + str(u_min) + ', rho = ' + str(rho))\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.plot(t_fwhms, t_es_point, label='Point')\nplt.plot(t_fwhms, t_es_finite, label='Finite')\nplt.plot(t_fwhms, t_fwhms, label='t_fwhm', ls='--', color='k')\nplt.legend()\nplt.xlabel('t_fwhm')\nplt.ylabel('t_e')\nplt.title('u_min = ' + str(u_min) + ', rho = ' + str(rho))\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.plot(t_fwhms, t_es_point, label='Point')\nplt.plot(t_fwhms, t_es_finite, label='Finite')\nplt.plot(t_fwhms, t_fwhms, label='t_fwhm', ls='--', color='k')\nplt.legend()\nplt.xlabel('t_fwhm')\nplt.ylabel('t_e')\nplt.title('u_min = ' + str(u_min) + ', rho = ' + str(rho))\nplt.show()",
    "crumbs": [
      "utils"
    ]
  }
]